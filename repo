#!/usr/bin/env python

import sys

# copied from portable
def stream2str(stream):
    return str(stream, encoding='UTF-8')

if sys.version_info[0] < 3:
  print('git-repo is written for python3, your version is %s, please upgrade from www.python.org.' % sys.version)
  exit(0)

## repo default configuration
##
REPO_URL = 'https://github.com/esrlabs/git-repo'
REPO_REV = 'master'

# Copyright (C) 2008 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# increment this whenever we make important changes to this script
VERSION = (1, 19, 1)

# increment this if the MAINTAINER_KEYS block is modified
KEYRING_VERSION = (1, 1)
MAINTAINER_KEYS = """
    Matthias Putz (E.S.R.Labs) <matthias.putz@esrlabs.com>
-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: SKS 1.1.0

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
CWWfbB6lN1jvyojS5ZPw
=UVAj
-----END PGP PUBLIC KEY BLOCK-----

"""

GIT = 'git'                     # our git command
MIN_GIT_VERSION = (1, 7, 2)     # minimum supported git version
repodir = '.repo'               # name of repo's private directory
S_repo = 'repo'                 # special repo repository
S_manifests = 'manifests'       # special manifest repository
REPO_MAIN = S_repo + '/main.py' # main script


import optparse
import os
import re
import stat
import subprocess
import urllib.request
import urllib.error

home_dot_repo = os.path.expanduser('~/.repoconfig')
gpg_dir = os.path.join(home_dot_repo, 'gnupg')

extra_args = []
init_optparse = optparse.OptionParser(usage="repo init -u url [options]")

# Logging
group = init_optparse.add_option_group('Logging options')
group.add_option('-q', '--quiet',
                 dest="quiet", action="store_true", default=False,
                 help="be quiet")

# Manifest
group = init_optparse.add_option_group('Manifest options')
group.add_option('-u', '--manifest-url',
                 dest='manifest_url',
                 help='manifest repository location', metavar='URL')
group.add_option('-b', '--manifest-branch',
                 dest='manifest_branch',
                 help='manifest branch or revision', metavar='REVISION')
group.add_option('-m', '--manifest-name',
                 dest='manifest_name',
                 help='initial manifest file', metavar='NAME.xml')
group.add_option('--mirror',
                 dest='mirror', action='store_true',
                 help='create a replica of the remote repositories '
                      'rather than a client working directory')
group.add_option('--reference',
                 dest='reference',
                 help='location of mirror directory', metavar='DIR')
group.add_option('--depth', type='int', default=None,
                 dest='depth',
                 help='create a shallow clone with given depth; see git clone')
group.add_option('-g', '--groups',
                 dest='groups', default='default',
                 help='restrict manifest projects to ones with a specified group',
                 metavar='GROUP')
group.add_option('-p', '--platform',
                 dest='platform', default="auto",
                 help='restrict manifest projects to ones with a specified '
                      'platform group [auto|all|none|linux|darwin|...]',
                 metavar='PLATFORM')


# Tool
group = init_optparse.add_option_group('repo Version options')
group.add_option('--repo-url',
                 dest='repo_url',
                 help='repo repository location', metavar='URL')
group.add_option('--repo-branch',
                 dest='repo_branch',
                 help='repo branch or revision', metavar='REVISION')
group.add_option('--no-repo-verify',
                 dest='no_repo_verify', action='store_true',
                 help='do not verify repo source code')

# Other
group = init_optparse.add_option_group('Other options')
group.add_option('--config-name',
                 dest='config_name', action="store_true", default=False,
                 help='Always prompt for name/e-mail')

class CloneFailure(Exception):
  """Indicate the remote clone of repo itself failed.
  """


def _Init(args):
  """Installs repo by cloning it over the network.
  """
  opt, args = init_optparse.parse_args(args)
  if args:
    init_optparse.print_usage()
    sys.exit(1)

  url = opt.repo_url
  if not url:
    url = REPO_URL
    extra_args.append('--repo-url=%s' % url)

  branch = opt.repo_branch
  if not branch:
    branch = REPO_REV
    extra_args.append('--repo-branch=%s' % branch)

  if branch.startswith('refs/heads/'):
    branch = branch[len('refs/heads/'):]
  if branch.startswith('refs/'):
    print("fatal: invalid branch name '%s'" % branch, file=sys.stderr)
    raise CloneFailure()

  if not os.path.isdir(repodir):
    try:
      os.mkdir(repodir)
    except OSError as e:
      print('fatal: cannot make %s directory: %s'
            % (repodir, e.strerror), file=sys.stderr)
      # Don't raise CloneFailure; that would delete the
      # name. Instead exit immediately.
      #
      sys.exit(1)

  _CheckGitVersion()
  try:
    if NeedSetupGnuPG():
      can_verify = SetupGnuPG(opt.quiet)
    else:
      can_verify = True

    dst = os.path.abspath(os.path.join(repodir, S_repo))
    _Clone(url, dst, opt.quiet)

    if can_verify and not opt.no_repo_verify:
      rev = _Verify(dst, branch, opt.quiet)
    else:
      rev = 'refs/remotes/origin/%s^0' % branch

    _Checkout(dst, branch, rev, opt.quiet)
  except CloneFailure:
    if opt.quiet:
      print('fatal: repo init failed; run without --quiet to see why',
            file=sys.stderr)
    raise


def _CheckGitVersion():
  cmd = [GIT, '--version']
  try:
    proc = subprocess.Popen(cmd, stdout=subprocess.PIPE)
  except OSError as e:
    print(file=sys.stderr)
    print("fatal: '%s' is not available" % GIT, file=sys.stderr)
    print('fatal: %s' % e, file=sys.stderr)
    print(file=sys.stderr)
    print('Please make sure %s is installed and in your path.' % GIT,
          file=sys.stderr)
    raise CloneFailure()

  ver_str = stream2str(proc.stdout.read()).strip()
  proc.stdout.close()
  proc.wait()

  if not ver_str.startswith('git version '):
    print('error: "%s" unsupported' % ver_str, file=sys.stderr)
    raise CloneFailure()

  ver_str = ver_str[len('git version '):].strip()
  ver_act = tuple(map(int, ver_str.split('.')[0:3]))
  if ver_act < MIN_GIT_VERSION:
    need = '.'.join(map(str, MIN_GIT_VERSION))
    print('fatal: git %s or later required' % need, file=sys.stderr)
    raise CloneFailure()


def NeedSetupGnuPG():
  if not os.path.isdir(home_dot_repo):
    return True

  kv = os.path.join(home_dot_repo, 'keyring-version')
  if not os.path.exists(kv):
    return True

  kv = open(kv).read()
  if not kv:
    return True

  kv = tuple(map(int, kv.split('.')))
  if kv < KEYRING_VERSION:
    return True
  return False


def SetupGnuPG(quiet):
  if not os.path.isdir(home_dot_repo):
    try:
      os.mkdir(home_dot_repo)
    except OSError as e:
      print('fatal: cannot make %s directory: %s'
            % (home_dot_repo, e.strerror), file=sys.stderr)
      sys.exit(1)

  if not os.path.isdir(gpg_dir):
    try:
      os.mkdir(gpg_dir, stat.S_IRWXU)
    except OSError as e:
      print('fatal: cannot make %s directory: %s' % (gpg_dir, e.strerror),
            file=sys.stderr)
      sys.exit(1)

  env = os.environ.copy()
  env['GNUPGHOME'] = gpg_dir

  cmd = ['gpg', '--import']
  try:
    proc = subprocess.Popen(cmd,
                            env = env,
                            stdin = subprocess.PIPE)
  except OSError as e:
    if not quiet:
      print('warning: gpg (GnuPG) is not available.', file=sys.stderr)
      print('warning: Installing it is strongly encouraged.', file=sys.stderr)
      print(file=sys.stderr)
    return False

  proc.stdin.write(MAINTAINER_KEYS.encode())
  proc.stdin.close()

  if proc.wait() != 0:
    print('fatal: registering repo maintainer keys failed', file=sys.stderr)
    sys.exit(1)
  print()

  fd = open(os.path.join(home_dot_repo, 'keyring-version'), 'w')
  fd.write('.'.join(map(str, KEYRING_VERSION)) + '\n')
  fd.close()
  return True


def _SetConfig(local, name, value):
  """Set a git configuration option to the specified value.
  """
  cmd = [GIT, 'config', name, value]
  if subprocess.Popen(cmd, cwd = local).wait() != 0:
    raise CloneFailure()


def _InitHttp():
  handlers = []

  mgr = urllib.request.HTTPPasswordMgrWithDefaultRealm()
  try:
    import netrc
    n = netrc.netrc()
    for host in n.hosts:
      p = n.hosts[host]
      mgr.add_password(p[1], 'http://%s/'  % host, p[0], p[2])
      mgr.add_password(p[1], 'https://%s/' % host, p[0], p[2])
  except:
    pass
  handlers.append(urllib.request.HTTPBasicAuthHandler(mgr))
  handlers.append(urllib.request.HTTPDigestAuthHandler(mgr))

  if 'http_proxy' in os.environ:
    url = os.environ['http_proxy']
    handlers.append(urllib.request.ProxyHandler({'http': url, 'https': url}))
  if 'REPO_CURL_VERBOSE' in os.environ:
    handlers.append(urllib.request.HTTPHandler(debuglevel=1))
    handlers.append(urllib.request.HTTPSHandler(debuglevel=1))
  urllib.request.install_opener(urllib.request.build_opener(*handlers))

def _Fetch(url, local, src, quiet):
  if not quiet:
    print('Get %s' % url, file=sys.stderr)

  cmd = [GIT, 'fetch']
  if quiet:
    cmd.append('--quiet')
    err = subprocess.PIPE
  else:
    err = None
  cmd.append(src)
  cmd.append('+refs/heads/*:refs/remotes/origin/*')
  cmd.append('refs/tags/*:refs/tags/*')

  proc = subprocess.Popen(cmd, cwd = local, stderr = err)
  if err:
    proc.stderr.read()
    proc.stderr.close()
  if proc.wait() != 0:
    raise CloneFailure()

def _DownloadBundle(url, local, quiet):
  if not url.endswith('/'):
    url += '/'
  url += 'clone.bundle'

  proc = subprocess.Popen(
    [GIT, 'config', '--get-regexp', 'url.*.insteadof'],
    cwd = local,
    stdout = subprocess.PIPE)
  for line in proc.stdout:
    m = re.compile(r'^url\.(.*)\.insteadof (.*)$').match(line)
    if m:
      new_url = m.group(1)
      old_url = m.group(2)
      if url.startswith(old_url):
        url = new_url + url[len(old_url):]
        break
  proc.stdout.close()
  proc.wait()

  if not url.startswith('http:') and not url.startswith('https:'):
    return False

  dest = open(os.path.join(local, '.git', 'clone.bundle'), 'w+b')
  try:
    try:
      r = urllib.request.urlopen(url)
    except urllib.error.HTTPError as e:
      if e.code in [403, 404]:
        return False
      print('fatal: Cannot get %s' % url, file=sys.stderr)
      print('fatal: HTTP error %s' % e.code, file=sys.stderr)
      raise CloneFailure()
    except urllib.error.URLError as e:
      print('fatal: Cannot get %s' % url, file=sys.stderr)
      print('fatal: error %s' % e.reason, file=sys.stderr)
      raise CloneFailure()
    try:
      if not quiet:
        print('Get %s' % url, file=sys.stderr)
      while True:
        buf = r.read(8192)
        if buf == '':
          return True
        dest.write(buf)
    finally:
      r.close()
  finally:
    dest.close()

def _ImportBundle(local):
  path = os.path.join(local, '.git', 'clone.bundle')
  try:
    _Fetch(local, local, path, True)
  finally:
    os.remove(path)

def _Clone(url, local, quiet):
  """Clones a git repository to a new subdirectory of repodir
  """
  try:
    os.mkdir(local)
  except OSError as e:
    print('fatal: cannot make %s directory: %s' % (local, e.strerror),
          file=sys.stderr)
    raise CloneFailure()

  cmd = [GIT, 'init', '--quiet']
  try:
    proc = subprocess.Popen(cmd, cwd = local)
  except OSError as e:
    print(file=sys.stderr)
    print("fatal: '%s' is not available" % GIT, file=sys.stderr)
    print('fatal: %s' % e, file=sys.stderr)
    print(file=sys.stderr)
    print('Please make sure %s is installed and in your path.' % GIT,
          file=sys.stderr)
    raise CloneFailure()
  if proc.wait() != 0:
    print('fatal: could not create %s' % local, file=sys.stderr)
    raise CloneFailure()

  _InitHttp()
  _SetConfig(local, 'remote.origin.url', url)
  _SetConfig(local, 'remote.origin.fetch',
                    '+refs/heads/*:refs/remotes/origin/*')
  if _DownloadBundle(url, local, quiet):
    _ImportBundle(local)
  else:
    _Fetch(url, local, 'origin', quiet)


def _Verify(cwd, branch, quiet):
  """Verify the branch has been signed by a tag.
  """
  cmd = [GIT, 'describe', 'origin/%s' % branch]
  proc = subprocess.Popen(cmd,
                          stdout=subprocess.PIPE,
                          stderr=subprocess.PIPE,
                          cwd = cwd)
  cur = stream2str(proc.stdout.read()).strip()
  proc.stdout.close()

  proc.stderr.read()
  proc.stderr.close()

  if proc.wait() != 0 or not cur:
    print(file=sys.stderr)
    print("fatal: branch '%s' has not been signed" % branch, file=sys.stderr)
    raise CloneFailure()

  m = re.compile(r'^(.*)-[0-9]{1,}-g[0-9a-f]{1,}$').match(cur)
  if m:
    cur = m.group(1)
    if not quiet:
      print(file=sys.stderr)
      print("info: Ignoring branch '%s'; using tagged release '%s'"
            % (branch, cur), file=sys.stderr)
      print(file=sys.stderr)

  env = os.environ.copy()
  env['GNUPGHOME'] = gpg_dir.encode()

  cmd = [GIT, 'tag', '-v', cur]
  proc = subprocess.Popen(cmd,
                          stdout = subprocess.PIPE,
                          stderr = subprocess.PIPE,
                          cwd = cwd,
                          env = env)
  out = proc.stdout.read()
  proc.stdout.close()

  err = proc.stderr.read()
  proc.stderr.close()

  if proc.wait() != 0:
    print(file=sys.stderr)
    print(out, file=sys.stderr)
    print(err, file=sys.stderr)
    print(file=sys.stderr)
    raise CloneFailure()
  return '%s^0' % cur


def _Checkout(cwd, branch, rev, quiet):
  """Checkout an upstream branch into the repository and track it.
  """
  cmd = [GIT, 'update-ref', 'refs/heads/default', rev]
  if subprocess.Popen(cmd, cwd = cwd).wait() != 0:
    raise CloneFailure()

  _SetConfig(cwd, 'branch.default.remote', 'origin')
  _SetConfig(cwd, 'branch.default.merge', 'refs/heads/%s' % branch)

  cmd = [GIT, 'symbolic-ref', 'HEAD', 'refs/heads/default']
  if subprocess.Popen(cmd, cwd = cwd).wait() != 0:
    raise CloneFailure()

  cmd = [GIT, 'read-tree', '--reset', '-u']
  if not quiet:
    cmd.append('-v')
  cmd.append('HEAD')
  if subprocess.Popen(cmd, cwd = cwd).wait() != 0:
    raise CloneFailure()


def _FindRepo():
  """Look for a repo installation, starting at the current directory.
  """
  curdir = os.getcwd()
  repo = None

  olddir = None
  while curdir != '/' \
    and curdir != olddir \
    and not repo:
    repo = os.path.join(curdir, repodir, REPO_MAIN)
    if not os.path.isfile(repo):
      repo = None
      olddir = curdir
      curdir = os.path.dirname(curdir)
  return (repo, os.path.join(curdir, repodir))


class _Options:
  help = False


def _ParseArguments(args):
  cmd = None
  opt = _Options()
  arg = []

  for i in range(len(args)):
    a = args[i]
    if a == '-h' or a == '--help':
      opt.help = True

    elif not a.startswith('-'):
      cmd = a
      arg = args[i + 1:]
      break
  return cmd, opt, arg


def _Usage():
  print(
"""usage: repo COMMAND [ARGS]

repo is not yet installed.  Use "repo init" to install it here.

The most commonly used repo commands are:

  init      Install repo in the current working directory
  help      Display detailed help on a command

For access to the full online help, install repo ("repo init").
""", file=sys.stderr)
  sys.exit(1)


def _Help(args):
  if args:
    if args[0] == 'init':
      init_optparse.print_help()
      sys.exit(0)
    else:
      print("error: '%s' is not a bootstrap command.\n"
            '        For access to online help, install repo ("repo init").'
            % args[0], file=sys.stderr)
  else:
    _Usage()
  sys.exit(1)


def _NotInstalled():
  print('error: repo is not installed.  Use "repo init" to install it here.',
        file=sys.stderr)
  sys.exit(1)


def _NoCommands(cmd):
  print("""error: command '%s' requires repo to be installed first.
        Use "repo init" to install it here.""" % cmd, file=sys.stderr)
  sys.exit(1)


def _RunSelf(wrapper_path):
  my_dir = os.path.dirname(wrapper_path)
  my_main = os.path.join(my_dir, 'main.py')
  my_git = os.path.join(my_dir, '.git')

  if os.path.isfile(my_main) and os.path.isdir(my_git):
    for name in ['git_config.py',
                 'project.py',
                 'subcmds']:
      if not os.path.exists(os.path.join(my_dir, name)):
        return None, None
    return my_main, my_git
  return None, None


def _SetDefaultsTo(gitdir):
  global REPO_URL
  global REPO_REV

  REPO_URL = gitdir
  proc = subprocess.Popen([GIT,
                           '--git-dir=%s' % gitdir,
                           'symbolic-ref',
                           'HEAD'],
                          stdout = subprocess.PIPE,
                          stderr = subprocess.PIPE)
  REPO_REV = stream2str(proc.stdout.read()).strip()
  proc.stdout.close()

  proc.stderr.read()
  proc.stderr.close()

  if proc.wait() != 0:
    print('fatal: %s has no current branch' % gitdir, file=sys.stderr)
    sys.exit(1)


def main(orig_args):
  repo_main, rel_repo_dir = _FindRepo()
  cmd, opt, args = _ParseArguments(orig_args)

  wrapper_path = os.path.abspath(__file__)
  my_main, my_git = _RunSelf(wrapper_path)

  if not repo_main:
    if opt.help:
      _Usage()
    if cmd == 'help':
      _Help(args)
    if not cmd:
      _NotInstalled()
    if cmd == 'init':
      if my_git:
        _SetDefaultsTo(my_git)
      try:
        _Init(args)
      except CloneFailure:
        for root, dirs, files in os.walk(repodir, topdown=False):
          for name in files:
            os.remove(os.path.join(root, name))
          for name in dirs:
            os.rmdir(os.path.join(root, name))
        os.rmdir(repodir)
        sys.exit(1)
      repo_main, rel_repo_dir = _FindRepo()
    else:
      _NoCommands(cmd)

  if my_main:
    repo_main = my_main

  ver_str = '.'.join(map(str, VERSION))
  me = [sys.executable,
        repo_main, repo_main,
        '--repo-dir=%s' % rel_repo_dir,
        '--wrapper-version=%s' % ver_str,
        '--wrapper-path=%s' % wrapper_path,
        '--']
  me.extend(orig_args)
  me.extend(extra_args)
  try:
    subprocess.call(me)
  except OSError as e:
    print("fatal: unable to start %s" % repo_main, file=sys.stderr)
    print("fatal: %s" % e, file=sys.stderr)
    sys.exit(148)


if __name__ == '__main__':
  main(sys.argv[1:])
